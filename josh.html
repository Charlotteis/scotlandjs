---
layout: default
title: Speakers
---
<div class="container">
  <h1>Joshua Holbrook</h1>
  <h2>Everything Is Terrible: Why You Should Be Angry</h2>

  <div class="container">
    <div style="float:left">
      <img src='images/speakers/yesthisisjosh.jpg' style="width: 250px" />
      <p>
        <a href="http://twitter.com/jesusabdullah" target="_blank">@jesusabdullah</a>
      </p>

    </div>
    <div style="margin-left: 300px">
      <h3>Bio</h3>
      <p>
I'm an engineering student/researcher-turned-javascript programmer specializing in node.js. I was previously the Head of Support at Nodejitsu, and now I'm working on the Big framework (http://big.vc/developers). I like math, science, computers and the frigid Northern wastes of Alaska (where I grew up).
</p>

      <h3>Talk</h3>
    <p>
Node.js seems pretty sweet, sure. It has asynchronous IO, sane stream APIs, and one of the best package managers in open source. Plus, it's javascript.
</p>
<p>
But when it comes to node.js web frameworks, not all is well in the world. Why is the most commonly-used web framework pretty much the same as Sinatra? Why is the most common way of separating http app functionality based on a hack from WSGI? Why does installing an app pull down half of NPM? Why do we have to not only write routes at all, but write them multiple times, for server-side views, client-side views, json APIs and command-line interfaces, using a different router for each with arbitrarily different interfaces?
</p>
<p>
We can do better, and with the Big framework (also on github), I will show you how.
</p>
  </div>
  </div>

</div>
